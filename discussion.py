# Part 1: Discussion Questons

# Runtime

# 1. Because you would need to test whether every cracker is an elephant,
# the workload is determined by how many elephanta are in the box.

# 2. 
# O(1)
# O(log n)
# O(n)
# O(n log n)
# O(n^2)
# O(2^n)

# Stacks and Queues

# 1. 
#     1. stack 
#     2. queue
#     3. stack

# 2. A queue can also represent a line for buying coffee and 
# when multiple callers call the customer service line and have to wait on hold.

# 3. A stack can be used for when you eat a stack of pancakes and 
# when you use a circular dvd stack container.

# Linked Lists

# 1. 

# The 2-part boxes are the nodes. 

# The data is the text string in the first box.

# The head is the apple node(box with both parts) the arrow from head is pointing to.

# The tail is the cheery node(box with both parts) at the end which has a next box pointing to None.

# 2. Singly-linked lists point in one direction and you can only traverse them in one direction.
# The node points to one other node that's next.

# Doubly-linked lists point in both directions and can be traversed both ways.
# The node points to 2 nodes, the next and previous one.

# 3. In order to append to the end, you need to know what the last node is.
# If you have the tail, you can just add to that and update tail.
# Otherwise, you have to start at the beginning and traverse through
# the entire linked list until you get to the end.

# Trees

# 1. food, Italian, Indian, Mexican, lasagna, pizza, tikka masala, saag, burritos

# 2. food, Mexican, enchiladas, tacos, burritos, Indian, saag, tikka masala, Italian, pizza, Sicilian, New York-style, Chicago-style  

# (If it was done from the other direction, this would result:
# food, Italian, lasgna, pizza, thin crust, Chicago-style)


# 3. The binary search trees make it easy to search items by being balanced and ordered.
# The approximate median item should be the root with one side being less and one side being greater.
# This is repeated at each child node such that it is easy to search for an item 
# by choosing the right direction depending on how the data compare.

